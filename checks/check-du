#!/usr/bin/env perl

use strict;
use warnings;
use Bloonix::Plugin;
use File::Temp qw(:mktemp);
use Date::Format qw(time2str);

#------------------------------------------------------------------------------
#
# Author      : Ebow Halm <ejh@cpan.org>
# Date        : Feb 2017
# Description : Bloonix plugin to check directory size.
# License     : Apache 2.0. Copyright (C) 2017 Ebow Halm.
#
#------------------------------------------------------------------------------

###########     Integrate into Bloonix plugin infrastructure.      ############

my $plugin = Bloonix::Plugin->new( version => '0.6' );
$plugin->has_timeout( default => 10 );

$plugin->info(
    join( " ",
        "This plugin checks the size and inode count of a directory.",
        "To do this, it requires a cron job to be run.",
        "The script the cron job should run has been installed to: ",
        "'/usr/lib/bloonix/etc/cron/cron-du'.",
        "To setup this plugin to check the size of the /var/www directory",
        "for example, first choose a unique identifier (eg 'var_www').",
        "Enter 'var_www' as the value of the Identifier value under",
        "Check settings.",
        "Then create a cronjob that has 'var_www' and '/var/www' passed",
        "to the cron script '/usr/lib/bloonix/etc/cron/cron-du' like this: ",
        "* */1 * * * /usr/lib/bloonix/etc/cron/cron-du var_www /var/www",
    )
);
$plugin->add_option(
    name        => 'Identifier',
    option      => 'identifier',
    description => 'Unique identifier for this check',
    value_type  => 'string',
    example     => 'my_identifier',
    mandatory   => 1,
);

$plugin->has_threshold(
    keys => [ { key => 'inodes' }, { key => 'size', unit => 'bytes' } ] );

$plugin->example(
    description =>
        'Warn when directory is greater than 1MB or has more than 100 inodes',
    arguments => [
        identifier => 'my_identifier',
        critical   => "inodes:gt:100",
        warning    => "size:gt:1MB",
    ]
);

my $opt = $plugin->parse_options;

#------------------------------------------------------------------------------

###########     Verify basic pre-requisites are satisfied.         ############
#
# What is the status of the cron job run?
#
# - Have we processed the cron job's output before?
# - Has the cron job run since the last time we processed its output?
# - Did the last cron job run produce an error?
#
# - We've processed the cron job's output before if a .last_processed file
#   exists (we create that file).
# - An err.log file exists if the last run of the cron job produced an error.
# - A $domain.json file exists if the last cron job run did not produce an
#   error and we haven't processed those results.
#
# The cron job could be writing the error file our the output file as we read
# it so do prevent the two processes from stomping on each other by doing it
# atomically, rename the file to be read and then read the renamed file.
#
# File format is almost but not quite JSON; the attributes (inodes, size) are
# not quoted. An example is:
#
# {
#   inodes: 22,
#   size: 47593
# }

#------------------------------------------------------------------------------

# 'Constants'
my $CHECK          = 'du';
my $LOG_DIR        = '/var/cache/bloonix';
my $ERROR_LOG      = "$LOG_DIR/$CHECK.err.log";
my $RESULT         = "$LOG_DIR/${CHECK}_$opt->{identifier}.txt";
my $LAST_PROCESSED = "$RESULT.last_processed";

#------------------------------------------------------------------------------

eval {
    local $SIG{ALRM} = sub { die "alarm\n" };    # NB: \n required
    alarm $opt->{timeout};
    my $results = check_cronjob_status( $ERROR_LOG, $opt->{test} || $RESULT,
        $LOG_DIR, $CHECK );
    process_results( $results, $LAST_PROCESSED );
    alarm(0);
};
if ($@) {
    $plugin->exit(
        status  => 'CRITICAL',
        message => $@ eq "alarm\n"
        ? "Timed out after $opt->{timeout} seconds."
        : $@
    );
}

#------------------------------------------------------------------------------

sub check_cronjob_status {

    my ( $error_log, $results_file, $log_dir, $check ) = @_;

    local $/;
    my $tmp = mktemp("$log_dir/.tmp.$check.XXXXXXXXXX");
    warn("Results   : $results_file\nTemp    : $tmp\n");

    if ( rename $error_log, $tmp ) {

        # An error occcurred during the last cron run.

        if ( open( my $fh, "<", $tmp ) ) {

            my $err = <$fh>;
            chomp($err);

            my $mtime;
            (   undef, undef, undef, undef, undef,
                undef, undef, undef, undef, $mtime,
            ) = stat($fh);
            close($fh);
            unlink $tmp;

            my $date = time2str( '%C', $mtime );
            $plugin->exit(
                status  => 'UNKNOWN',
                message => "Cron job run on $date error: $err"
            );

        }

        unlink $tmp;
        $plugin->exit(
            status  => 'UNKNOWN',
            message => "Error during last cron job run."
        );

    }

    # Has there been a cron job run that we haven't processed?
    unless ( rename $results_file, $tmp ) {

        # The cron job hasn't run (or hasn't run since the last time we
        # processed it's output).

       # If there is no cron job output to process (so no statistics to send),
       # just report the last time the cron job run (ie the time of the last
       # results we processed).

        if ( -e $LAST_PROCESSED ) {
            my $mtime;
            (   undef, undef, undef, undef, undef,
                undef, undef, undef, undef, $mtime,
            ) = stat($LAST_PROCESSED);
            my $date = time2str( '%C', $mtime );
            $plugin->exit(
                status  => 'OK',
                message => "No new data. Cron job's last run ended at: $date."
            );
        }
        $plugin->exit(
            status  => 'UNKNOWN',
            message => "Cron job has not been run."
        );

    }
    $tmp;
}

#------------------------------------------------------------------------------

sub process_results {

    my ( $file, $rename ) = @_;

    my $fh;
    unless ( open( $fh, "<", $file ) ) {
        rename $file, $rename;
        $plugin->exit(
            status  => 'UNKNOWN',
            message => "Cannot open $file: $!."
        );
    }

    local $/;
    my $output = <$fh>;
    close($fh);
    rename $file, $rename;

    my $stats;
    while ( $output =~ /([a-z]++)\s*+:\s*+([0-9]++)/gcm ) {
        $stats->{$1} = $2;
    }

    unless ( exists $stats->{size} && exists $stats->{inodes} ) {
        $plugin->exit(
            status  => 'UNKNOWN',
            message => "$file must have 'size' and 'inodes' attributes."
        );
    }

    # Both attributes must have integer values.
    unless ( $stats->{size} =~ /^[0-9]+$/ && $stats->{inodes} =~ /^[0-9]+$/ )
    {
        $plugin->exit(
            status => 'UNKNOWN',
            message =>
                "$file 'size' and 'inodes' attribute values must be integers."
        );
    }

    $plugin->check_thresholds(
        stats       => $stats,
        upshot_keys => [qw(inodes size)],
        exit        => "yes"
    );
}

#------------------------------------------------------------------------------
