#!/usr/bin/perl

# Imports
use warnings;
use strict;
use Bloonix::Plugin;
use Data::Dumper qw(Dumper);


# --------------------------------------------------
# Basics
# --------------------------------------------------

my $plugin = Bloonix::Plugin->new(version => "0.2");

$plugin->info(
    "The command '/usr/bin/time' is used to execute cronjobs and gather statistics.",
);

# Define available treshholds
$plugin->has_threshold(
    keys => [
        { key => "unshared_size", unit => "bytes" },
        { key => "major_page_fault", unit => "bytes" },
        { key => "avg_mem_kbytes", unit => "bytes" },
        { key => "max_res_kbytes", unit => "bytes" },
        { key => "system_page_size", unit => "bytes" },
        { key => "avg_res_size", unit => "bytes" },
        { key => "cpu_percent", unit => "percent" },
        { key => "system_time" },
        { key => "user_time" },
        { key => "real_time" },
        { key => "reads" },
        { key => "writes" },
        { key => "minor_page_fault" },
        { key => "swap_num" },
        { key => "invol_context_switches" },
        { key => "signal_number" },
        { key => "sock_msg_rec" },
        { key => "sock_msg_send" },
        { key => "vol_context_switches" },
        { key => "exit_code" }
    ]
);

# Example usage
$plugin->example(
    description => [
        "How to check the status file of a cronjob.",
        "The following check configuration would trigger:",
        "",
        "- the results file generated by the bloonix-cronjob-helper script used in a cronjob",
        "  would be interpreted for its results.",
        "- a warning state would be triggered if the time the cronjob ran was higher than 60 seconds",
        "- a critical state would be triggered if the ext code of the cronjob was higher than zero"
    ],
    arguments => [
        statusfile => "/var/lib/bloonix/agent/cronjob/root/my_php_cronjob_identifier",
        warning => "real_time:ge:60",
        critical => "exit_code:gt:0"
    ]
);



# --------------------------------------------------
# Manage available options for the check
# --------------------------------------------------

# Plugin option definition
$plugin->add_option(
    name => "The full path to the cronjobs status file",
    option => "statusfile",
    value_type => "string",
    value_desc => "Path to the cronjobs status file",
    mandatory => 1,
    multiple => 0,
    description => "The path to the statusfile for the cronjob"
    # TODO Perl regex for a full linux path
    #regex => qr!https{0,1}://[a-zA-Z0-9]+([.-][a-zA-Z0-9]+)*(:\d+){0,1}(/[^\s]*){0,1}\z!,
);

# Parse options
my $opt = $plugin->parse_options;




# --------------------------------------------------
# Validation for input of statusfile argument
# --------------------------------------------------

# Check if the cronjob results file is present at all
my $filename = $opt->{statusfile};
if (! -e $filename) {
    $plugin->exit(
        status => "UNKNOWN",
        message => "Unable to read file: ${filename}",
    );
}



# --------------------------------------------------
# Process the cronjobs status file
# --------------------------------------------------

# Read the file with the results of the cronjob and iterate over the lines
my $status_hash = {};
open my $status_file, '<', "${filename}" or die "Can't open ${filename}: $!";
while (my $line = <$status_file>) {

    # Remove newlines and empty lines
    chomp $line;

    # Split the lines into two elements by whitespaces - first element and rest
    my @elements = split / /, $line, 2;
    #print Dumper \@elements;

    # Append each element to the stats dictionary returned to bloonix
    $status_hash->{$elements[0]} = $elements[1];

}

#print Dumper $status_hash;



# --------------------------------------------------
# Check warning and critical
# --------------------------------------------------

my $result = $plugin->check_thresholds(
    stats => $status_hash,
    upshot_keys => [qw(exit_code real_time cpu_percent avg_mem_kbytes)]
);

$plugin->exit(
    status => $result->{status},
    message => $result->{upshot},
    stats => $status_hash
);
