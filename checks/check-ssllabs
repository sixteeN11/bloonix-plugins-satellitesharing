#!/usr/bin/env perl

use strict;
use warnings;
use Bloonix::Plugin;
use JSON;
use File::Temp qw(:mktemp);
use Date::Format qw(time2str);

#------------------------------------------------------------------------------
#
# Author      : Ebow Halm <ejh@cpan.org>
# Created     : Feb 2017.
# Description : Bloonix plugin to check SSL setups.
# License     : Apache 2.0. Copyright (C) 2017 Ebow Halm.
#
#------------------------------------------------------------------------------

###########     Integrate into Bloonix plugin infrastructure.      ############

my $plugin = Bloonix::Plugin->new( version => '0.6' );
$plugin->has_timeout(default => 10);

$plugin->info(
    join( " ",
        "This plugin checks a domain and gives it an SSL grade.",
        "To do this, it requires a cron job to be run.",
        "The script the cron job should run has been installed to: ",
        "'/usr/lib/bloonix/etc/cron/cron-ssllabs'.",
        "For the cron script to work, you must install the ssllabs-scan",
        "utility from https://github.com/ssllabs/ssllabs-scan on the machine",
        "that runs the agent that has to execute the cronjob.",
        "To setup this plugin to check the domain 'blunix.com'",
        "for example",
        "enter 'blunix.com' as the value of the domain input under",
        "Check settings.",
        "Then create a cronjob that has 'blunix.com' passed",
        "to the cron script '/usr/lib/bloonix/etc/cron/cron-ssllabs' like this: ",
        "* */5 * * * /usr/lib/bloonix/etc/cron/cron-ssllabs blunix.com",
        "Note that a file named /var/cache/bloonix/ssllabs_blunix.com.json",
        "will be created by the cron job and will be read by the agent",
    )
);

$plugin->add_option(
    name        => 'Domain',
    option      => 'domain',
    description => 'Domain to check with SSLLabs',
    value_type  => 'string',
    example     => 'www.example.com',
    mandatory   => 1,
);

$plugin->add_option(
    name        => 'Grade',
    option      => 'grade',
    description => 'Grade domain should meet or beat',
    value_type  => 'string',
    value       => 'A+|A|A-|B+|B|B-|C+|C|C-|D+|D|D-|E+|E|E-',
    regex       => qr/^[A-E][-+]?\z/,
    mandatory   => 1,
);

$plugin->example(
    description =>
        "Warn when blunix.com's SSLLabs scan grade is worse than A",
    arguments => [
        domain => 'blunix.com',
        grade  => 'A'
    ]
);

my $opt = $plugin->parse_options;

#------------------------------------------------------------------------------

###########              ############
#
# What is the status of the cron job run?
#
# - Have we processed the cron job's output before?
# - Has the cron job run since the last time we processed its output?
# - Did the last cron job run produce an error?
#
# - We've processed the cron job's output before if a .last_processed file
#   exists (we create that file).
# - An err.log file exists if the last run of the cron job produced an error.
# - A $domain.json file exists if the last cron job run did not produce an
#   error and we haven't processed those results.
#
# The cron job could be writing the error file our the output file as we read
# it so do prevent the two processes from stomping on each other by doing it
# atomically, rename the file to be read and then read the renamed file.
#

my $CHECK          = 'ssllabs';
my $LOG_DIR        = '/var/cache/bloonix';
my $ERROR_LOG      = "$LOG_DIR/$CHECK.err.log";
my $RESULT         = $opt->{test} || "$LOG_DIR/${CHECK}_$opt->{domain}.json";
my $LAST_PROCESSED = "$LOG_DIR/${CHECK}_$opt->{domain}.last_processed";

# Implementations of mktemp(), tmpnam(), and tempnam() are provided, but should
# be used with caution since they return only a filename that was valid when
# function was called, so cannot guarantee that the file will not exist by the
# time the caller opens the filename.
#
# ($fh, $filename) = tempfile($template, DIR => $your_dir, UNLINK => 0);

local $/;

my $tmp = mktemp("$LOG_DIR/.tmp.$CHECK.XXXXXXXXXX");

if ( rename $ERROR_LOG, $tmp ) {

    # An error occcurred during the last cron run.

    if ( open( my $fh, "<", $tmp ) ) {

        my $err = <$fh>;
        chomp($err);

        my $mtime;
        (   undef, undef, undef, undef, undef,
            undef, undef, undef, undef, $mtime,
        ) = stat($fh);
        close($fh);
        unlink $tmp;

        my $date = time2str( '%C', $mtime );
        $plugin->exit(
            status  => 'UNKNOWN',
            message => "Cron job run on $date error: $err"
        );

    }

    unlink $tmp;
    $plugin->exit(
        status  => 'UNKNOWN',
        message => "Error during last cron job run."
    );

}

# Has there been a cron job run that we haven't processed?
if ( rename $RESULT, $tmp ) {

    # Process the results from the last cron run.
    process_result($tmp);
} else {

    # The cron job hasn't run (or hasn't run since the last time we
    # processed it's output).

    # If there is no cron job output to process (so no statistics to send),
    # just report the last time the cron job run (ie the time of the last
    # results we processed).

    if ( -e $LAST_PROCESSED ) {
        my $mtime;
        (   undef, undef, undef, undef, undef,
            undef, undef, undef, undef, $mtime,
        ) = stat($LAST_PROCESSED);
        my $date = time2str( '%C', $mtime );
        $plugin->exit(
            status  => 'OK',
            message => "No new data. Cron job's last run ended at: $date."
        );
    }
    $plugin->exit(
        status  => 'UNKNOWN',
        message => "Cron job has not been run."
    );

}

sub process_result {

    my $file = shift;
    my $fh;
    unless ( open( $fh, "<", $file ) ) {
        rename $file, $LAST_PROCESSED;
        $plugin->exit(
            status  => 'UNKNOWN',
            message => "Cannot open '$RESULT' $!."
        );
    }

    my $output = <$fh>;
    close($fh);
    rename $file, $LAST_PROCESSED;

    my $results;
    eval { 
        local $SIG{ALRM} = sub { die "alarm\n" };    # NB: \n required
        alarm $opt->{timeout};
        $results = decode_json $output; 
        alarm(0);
    };
    if ($@) {

        if ($@ =~ /alarm/) {
            $plugin->exit(
                status  => 'CRITICAL',
                message => "Timed out after $opt->{timeout} seconds." : $@
            );
        }

        $plugin->exit(
            status  => 'UNKNOWN',
            message => "Invalid file format '$file'.  $@."
        );
    }

    my $grade = $results->[0]->{endpoints}->[0]->{grade};
    my $gradeTrustIgnored
        = $results->[0]->{endpoints}->[0]->{gradeTrustIgnored};

    if ($grade) {

        my $pass = 0;    # Assume failure by default.
        my ( $min_letter_grade, $min_qualifier )
            = $opt->{grade} =~ /^(.)(.?)/;
        my ( $letter, $qualifier ) = $grade =~ /^(.)(.?)/;

        if ( $letter lt $min_letter_grade ) {
            $pass = 1;    # 'A' is less than 'B' but is a better grade.
        } elsif ( $letter eq $min_letter_grade ) {
            if ($min_qualifier) {
                if ( $min_qualifier eq '-' ) {
                    $pass = 1;   # Can't get a worse grade for a given letter.
                } else {
                    $pass = 1 if $qualifier && $qualifier eq '+';
                }
            } else {
                $pass = 1 unless $qualifier && $qualifier eq '-';
            }
        }

        if ($pass) {
            $plugin->exit(
                status => 'OK',
                message =>
                    "SSL grade=$grade, gradeTrustIgnored=$gradeTrustIgnored"
            );
        }

        $plugin->exit(
            status => 'WARNING',
            message =>
                "SSL grade=$grade is worse than minimum grade=$opt->{grade}"
        );

    }

    $plugin->exit(
        status  => 'UNKNOWN',
        message => "SSL grade not found in '$RESULT'."
    );
}

#------------------------------------------------------------------------------
